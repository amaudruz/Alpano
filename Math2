package ch.epfl.alpano;

import java.util.function.DoubleUnaryOperator;

public interface Math2 {
    
    double PI2 = 2 * Math.PI;
    
    public static double sq(double x){
        return x * x;
    }
    
    public static double floorMod(double x, double y){
        double mod = x - y * Math.floor(x/y);
        return mod;
    }

    public static double haversin(double x){
        double sinus = Math.sin(x/2);
        return sinus * sinus;
    }
    
    public static double angularDistance(double a1, double a2){
        return floorMod(a2 - a1 + Math.PI, PI2) - Math.PI;
    }
    
    public static double lerp(double y0, double y1, double x){
        return (y1 - y0) * x - y0;
    }
    
    public static double bilerp(double z00, double z10, double z01, double z11,
            double x, double y){
        
        double lerp1 = lerp(z00, z10, x);
        double lerp2 = lerp(z01, z11, x);
        return lerp(lerp1, lerp2, y);
        
    }
    
    public static double firstIntervalContainingRoot(DoubleUnaryOperator f, double minX, double maxX, double dX){
    
        for (int i = minX; i <= maxX; i+dX) {
        
            if (f.applyAsDouble(i) < 0 && (f.applyAsDouble(i+dX) > 0){
                return i;
            }
            
            if (f.applyAsDouble(i) > 0 && (f.applyAsDouble(i+dX) <0){
                return i;
            }
            
            if (f.applyAsDouble(i) == 0) {
                return i;
            }
            
            if (f.applyAsDouble(i+dX) == 0 && i <= maxX - dX) {
                return (i+dX);
            }

        }
        
        return Double.POSITIVE_INFINITY;
        
    }
}
